#!/bin/sh -eu

sort_and_append() {
    # Sort outputs to make them searchable using bsearch(). Remove
    # last comma.
    sort "$1" | sed '$ s/,$//'
}

is_null() {
    test "$1" = - -o "$1" = NULL
}

pointerize() {
    if is_null "$1"; then
	echo -n NULL
    else
	# Output the function name with a prefix
	echo -n "&${2-}$1"
    fi
}

prototype() {
    if ! is_null "$2"; then
	echo "$1$2;" >&3
    fi
}

protos="`mktemp`"
ascii="`mktemp`"
modbus="`mktemp`"
exec 3>"$protos"
exec 4>"$ascii"
exec 5>"$modbus"

# File header
cat <<EOF
// Automatically generated file. Edit avr/commands.tsv instead!
#include <stdlib.h>
#include <avr/pgmspace.h>
#include "cmd.h"
#include "juksautin.h"
#include "clock.h"

EOF

# Skip header line
read foo

while read type address name r_read r_write r_printer r_scanner; do
    # Make functions pointers
    fp_read="`pointerize "$r_read"`"
    fp_write="`pointerize "$r_write"`"
    fp_printer="`pointerize "$r_printer" cmd_print_`"
    fp_scanner="`pointerize "$r_scanner" cmd_scan_`"

    # Create prototypes for functions in cmd_functions.c
    prototype "cmd_print_t cmd_print_" "$r_printer"
    prototype "cmd_scan_t cmd_scan_" "$r_scanner"

    # Create prototypes for getters and setters (to validate type
    # safety on the way)
    prototype "get_${r_printer}_t " "$r_read"
    prototype "set_${r_scanner}_t " "$r_write"
    
    # Produce lines for both ASCII interface and Modbus
    action="{ $fp_read, $fp_write }"
    if test "$name" != -; then
	# PROGMEM strings must be outside of array initialization
	echo "static char const name_$name[] PROGMEM = \"$name\";"
	# The actual array item
	echo "	{ name_$name, $action, $fp_printer, $fp_scanner }," >&4
    fi
    if test "$type" != -; then
	echo "	{`printf %2d  "$type"`, 0x`printf %04x "$address"`, $action }," >&5
    fi
done

# Prototypes. Only once per function.
echo
sort -u $protos

# Ascii table header
cat <<EOF

cmd_ascii_t const cmd_ascii[] PROGMEM = {
EOF

# ASCII table content
sort_and_append "$ascii"

# Boilerplate between ASCII and Modbus tables
cat <<EOF
};

cmd_modbus_t const cmd_modbus[] PROGMEM = {
EOF

# Modbus table content
sort_and_append "$modbus"

# Trailing content
cat <<EOF
};

int const cmd_ascii_len = sizeof(cmd_ascii) / sizeof(*cmd_ascii);
int const cmd_modbus_len = sizeof(cmd_modbus) / sizeof(*cmd_modbus);
EOF

rm "$protos" "$ascii" "$modbus"
