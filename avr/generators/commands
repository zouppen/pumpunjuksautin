#!/bin/sh -eu

is_null() {
    test "$1" = - -o "$1" = NULL
}

prototype() {
    echo "$1;" >&3
}

protos="`mktemp`"
ascii="`mktemp`"
modbus="`mktemp`"
exec 3>"$protos"
exec 4>"$ascii"
exec 5>"$modbus"

# File header
cat <<EOF
// Automatically generated file. Edit avr/commands.tsv instead!
#include <stdlib.h>
#include <avr/pgmspace.h>
#include "cmd.h"
#include "juksautin.h"
#include "clock.h"
#include "misc.h"

EOF

# Skip header line
read foo

while read objtype address name r_read r_write datatype; do
    fp_get=NULL
    fp_set=NULL
    fp_printer=NULL
    fp_scanner=NULL
    fp_bin_read=NULL
    fp_bin_write=NULL
    
    if ! is_null "$r_read"; then
	# Create prototype for getter to validate type safety on the way
	fp_get="&$r_read"
	prototype "get_${datatype}_t $r_read"

	if ! is_null "$name"; then
	    fp_printer="&cmd_print_$datatype"
	    prototype "cmd_print_t cmd_print_$datatype"
	fi
	if ! is_null "$objtype"; then
	    fp_bin_read="&cmd_bin_read_$datatype"
	    prototype "cmd_bin_read_t cmd_bin_read_$datatype"
	fi
    fi

    if ! is_null "$r_write"; then
	# Create prototype for setter to validate type safety on the way
	fp_set="&$r_write"
	prototype "set_${datatype}_t $r_write"

	if ! is_null "$name"; then
	    fp_scanner="&cmd_scan_$datatype" 
            prototype "cmd_scan_t cmd_scan_$datatype"
	fi
	if ! is_null "$objtype"; then
	    fp_bin_write="&cmd_bin_write_$datatype"
	    prototype "cmd_bin_write_t cmd_bin_write_$datatype"
	fi
    fi
    
    # Produce lines for both ASCII interface and Modbus
    action="{ $fp_get, $fp_set }"
    if test "$name" != -; then
	# PROGMEM strings must be outside of array initialization
	echo "static char const name_$name[] PROGMEM = \"$name\";"
	# The actual array item
	echo "	{ name_$name, $action, $fp_printer, $fp_scanner }," >&4
    fi
    if test "$objtype" != -; then
	echo "	{`printf %2d  "$objtype"`, 0x`printf %04x "$address"`, $action, $fp_bin_read, $fp_bin_write}," >&5
    fi
done

# Prototypes. Only once per function.
echo
sort -u $protos

# Ascii table header
cat <<EOF

cmd_ascii_t const cmd_ascii[] PROGMEM = {
EOF

# ASCII table content
sort "$ascii"

# Boilerplate between ASCII and Modbus tables
cat <<EOF
};

cmd_modbus_t const cmd_modbus[] PROGMEM = {
EOF

# Modbus table content
sort "$modbus"

# Trailing content
cat <<EOF
};

int const cmd_ascii_len = sizeof(cmd_ascii) / sizeof(*cmd_ascii);
int const cmd_modbus_len = sizeof(cmd_modbus) / sizeof(*cmd_modbus);
EOF

rm "$protos" "$ascii" "$modbus"
